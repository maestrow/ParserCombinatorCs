# ѕередача переменных внутри парсера

¬ [OMeta](https://en.wikipedia.org/wiki/OMeta) существует возможность создани€ параметризированных правил 
(см. [конспект](https://gist.github.com/maestrow/e3bf3b6b930b6d791fa443e897d5d5bb) и оригинальную статью 
[Experimenting with Programming Languages. A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Computer Science" by Alessandro Warth.](http://www.vpri.org/pdf/tr2008003_experimenting.pdf), 
раздел "2.2.2.3 Parameterized Rules" на стр. 37
). ѕримеры:

```
charRange :x :y = char:c ?(x <= c && c <= y) -> c
lowerCase = charRange(ТaТ, ТzТ)
```

```
eq = Т=Т -> {kind: Т=Т, value: Т=Т},
num = digit+:ds -> {kind: ТnumТ, value: parseInt(ds.join(ТТ))},
id = letter+:ls -> {kind: ТidТ, value: ls.join(ТТ)},
scanner = space* (eq | num | id),
token :k = scanner:t ?(t.kind == k) -> t.value,
assign = token(ТidТ) token(Т=Т) token(ТnumТ)
```

‘актически здесь мы имеем дело не с объ€влением правила, а с функцией, котора€ возвращает правило.
“аковой, например, €вл€етс€ функци€ `Parser Char(char ch)` из фабрики `Combinator.Atomics.Parsers`. 
Ќо есть одно существенное отличие от имеющегос€ функционала - возможность создавать и примен€т парсер внутри кода другого парсера.

¬ OMeta/Js передача парамтеров в правило реализуетс€ через стек состо€ни€. ¬ момент вызова правила аргументы записываютс€ в стек. 
ѕеред применением правила из стека извлекаютс€ параметры и присваиваютс€ аргументам. ¬ данной библиотеке передача аргументов реализована точно так же, 
см. `Demo.List.Grammar`. ¬торой, более очевидный, вариант реализации передачи парамтеров - это генерировать парсер внутри кода другого парсера с нужными параметрами.