# Парсеры, Правила, Контейнеры, Выражения

- Для реализации предстоящей задачи оптимизации необходимо подготовить почву - внедрить понятие парсера-контейнера
- Определение парсера сделует сделать более наглядным, например, таким как это сделано в Irony

Обе данные задачи будут решаться одновременно, т.к. обе они затрагивают определение парсера.


## Определение правил с помощью выражений, состоящих из парсеров и правил

Способ использования парсер генератора приблизить к тому как это реализовано в Irony

В Irony правила задаются следующим образом:

	var some = new Rule("name", "description")
	some.Expr = a1 + a2
	          | b1 + b2
	          | c1 + c2

Налицо удобство использования операторов + и |

### Способ 1

	var select = "SELECT" + fields + "FROM" + table
	select.Name = "Select"
	select.Description = "Some description"
	var sql = select | insert | ...
	sql.Name = "SQL Statement"

Так реализовано сейчас и это не удобно. Гораздо удобнее сначала определить переменные правил с именами и описаниями, 
а затем присвоить им выражения - как это сделано в Irony, см. способ 2.

### Способ 2

	var sql = Rule("SQL Statement")
	var select = Rule("Select", "Some Description")
	var insert = Rule("Insert")
	...

	sql.Expr = select | insert | ...

	select.Expr = "SELECT" + fields + "FROM" + table


### Переход ко второму способу

Т.о. мы имеем следующие классы объектов:

- парсер - это функция, пулученная генератором
- генератор - это функция, генерирующая парсер определенного типа по заданной конфигурации
- правило - выражение, состоящее из других правил и парсеров

Чтобы мы могли использовать операторы (+ |) в выражениях их аргументы должны быть объектами классов, причем не generic.
Т.к. только для класса можно переопределить оператор, а для делегатов, интерфейса и generic-класса - нельзя.

Чтобы в выражении можно было использовать как парсеры, так и правила, в также использовать при этом операторы, правило должно быть наследником парсера.



## Парсеры-контейнеры

### ЗАЧЕМ: Контейнеры вводятся для обеспечения возможности реализации оптимизации

После получения сгенерированной функции, построенной на основе некоторого исходного парсера, мы не сможем обратиться к исодному парсеру. 
Пример:
	
	public static class Parsers
	{	
		public static Parser Not(this Parser parser)
		{
			return new Parser() 
			{
				Fn = state => 
				{
					return new ParseResult(!state.Apply(parser).IsSuccess);
				}
			}
		}
	}
	...
	
	var newP = Parsers.Not(source);
	
Имея в распоряжении `newP`, мы не можем обратиться к исходному парсеру `source`.

Чтобы иметь возможность решать задачи оптимизации необходимо, чтобы 
парсеры, которые строятся на основе других парсеров представляли собой контейнеры, а не просто сгенерированную функуию.

Неоптимизированные ветки and или or могут находиться внутри других контейнерах, для которых оптимизаторов может и не существовать.
Поэтому нужно иметь возможность перебрать все узлы дерева контейнеров.
Реализация парсера в виде отдельного класса, а не просто в виде сконфигурированной генератором функции, имеет следующие преимущества:
Мы имеет полное дерево парсеров, которые будут применены. И можем его проанализировать и изменить. 
Как частный случай такого вмешательства - это возможность оптимизации перед выполнением.


### ЧТО

Контейнер - это класс, содержащий ссылку на исходный (или исходные парсеры). 
Контейнер - это частный случай парсера, поэтому, чтобы остальной инфраструктурой классов контейнер воспринимался как парсер, он должен быть наследником парсера. 
Т.к. контейнер - это наследник парсера, то в нем также есть ссылка на функцию парсера, которая обрабатывает исходные парсеры.
Контейнерами в частности являются: И, ИЛИ, НЕ, квантификаторы, трансформеры.


